# 命名空间
NB基本使用的是PSR-4的自动加载规范，内置不再提供类库文件的导入方法，采用命名空间方式定义和自动加载类库文件，有效的解决了多模块和Composer类库之间的命名空间冲突问题，并且实现了更加高效的类库自动加载机制。

如果不清楚命名空间的基本概念，可以参考PHP手册：[PHP命名空间](http://www.php.net/manual/zh/language.namespaces.php)

特别注意的是，如果你需要调用PHP内置的类库，或者第三方没有使用命名空间的类库，记得在实例化类库的时候加上 \，例如：
```php
// 错误的用法
$class = new stdClass();
$xml  =  new SimpleXmlElement($xmlstr);
// 正确的用法
$class = new \stdClass();
$xml  =  new \SimpleXmlElement($xmlstr);
```

## 默认规则
默认遵循PSR-4自动加载规范，只需要给类库正确定义所在的命名空间，并且命名空间的路径与类库文件的目录一致，那么就可以实现类的自动加载，从而实现真正的惰性加载。
例如，\module\bind\util\BindHelper类的定义为：
```php
namespace module\bind\util;

class BindHelper {

}
```
如果我们实例化该类的话，应该是：
```php
$helper = new \module\bind\util\BindHelper();
```
系统会自动加载该类对应路径的类文件，其所在的路径是`demo\module\bind\util\BindHelper.php`。
> NB目录规范是小写，类文件命名是驼峰法，并且首字母大写。

## 特殊规则
为了安全和方便，NB里有三种种情况是不按上面的默认规则的。

#### 1.控制器
在`简单访问`章节里，我们介绍了控制器的简单用法，它就是不按默认规则使用命名空间的。它的命名空间里必须包含`controller`虚拟目录。
这样的目的是为了保证访问请求不能请求到其它非控制器文件上来。

#### 2.应用目录
应用目录`application`是一个特殊的目录，它相当于一个默认的模块，也相当于一个公共目录。
因其使用频率极高，在它下面的一级目录里类，命名空间都简化为只需要当前目录名，不需要上一级的`application`，某些控制器除外。
如下：
```php
namespace daos;

use nb\Dao;
//命名空间不需要包含application
class Test extends Dao {

    public function __construct() {
        parent::__construct('test t','id','dao');
    }
}
```
所以，通常不建议`应用目录`下使用超过一级目录的层级。如果超过，你需要这样按照默认规则写命名空间：
```php
namespace application\common\xxxx;

class Test {

}
```

#### 3.自定义根命名空间
有时，我们遇到目录层级非常高，命名空间过长的问题，我们可以定一个根命名空间来缩短它，这需要在你框架配置里进行设置。
它是框架支持的自定义`PSR-4`规范。
比如有下面这样的一个类：
```php
namespace application\common\sub\xxxx;

class Test {

}
```
我们在框架配置里进行设置：
```php
class Config extends nb\Config {
    //自定义根命名空间
    public $namespace    = [
        'xxxx'=>__APP__.'application/common/sub/xxxx',
        'sub'=> __APP__.'application/common/sub'
    ];
}
```
> __APP__是项目的完整根路径

此时，我们就可以这样编写上面的命名空间了:
```php
//第一种
namespace xxxx;

class Test {

}
$test = new xxxx\Test;

//第二种
namespace sub\xxxx;

class Test {

}
$test = new sub\xxxx\Test;
```
 
#### 4.composer
默认框架会检测`__APP__vendor/autoload.php`文件是否存在，如果存在，将对其加载，用来支持composer。
不过通常是优先使用框架自己加载规则，当框架自身规则加载失败，才会用`composer`的规则继续加载。

如果你`__APP__vendor/autoload.php`文件存在，但是又不想使用它，或者使用其它自定义`autoload`文件。
你可以在框架配置里设置：
```php
class Config extends nb\Config {
    //设置自定义的composer加载文件
    public $composer    = __APP__.'autoload.php';
}
```




